# C++ 언어
- C++는 AT&T 벨 연구소의 비야네 스트롭스트룹이 C언어를 확장해서 만든 객체지향 프로그래밍 언어이다.
- 따라서 C가 가지고 있는 모든 기능이 C++안에 포함되어 있고, 몇 가지 새로운 내용이 C++에 추가되었다.
- C++는 C를 기반으로 개발된 언어이므로 몇 가지를 예외를 제외하고는 C의 문법을 그대로 따른다.
- 그러므로  C처럼 범용 프로그래밍 언어로서 다양한 응용프로그램을 개발하는데 활용될 수 있고, 시스템 프로그래밍을 위한 언어로도 활용할 수 있다.

# C++ 프로그램의 작성 및 빌드

## 소스 프로그램의 작성
- C++로 작성한 프로그램을 담고 있는 파일을 소스파일이라고 한다.
- C++프로그램의 소스 파일에는 C++소스 프로그램 파일과 C++ 헤더(header)파일이 있다.
### C++소스 프로그램 파일
- 간단한 프로그램이라면 하나의 소스 프로그램 파일에 프로그램을 완성할 수도 있다.
- 그러나 프로그램의 규모가 커지거나, 여러 개발자가 프로그램을 분담하여 작성할 경우에는 여러 개의 소스 프로그램 파일을 나누어 프로그램을 작성하게 된다.

### C++헤더(header)파일
- 여러 소스 프로그램 파일에 공통적으로 들어가야 하는 부분이 필연적으로 발생할 수 있다.
- 전역변수나 함수의 원형, 클래스 등의 선언문이 이러한 부분에 해당한다.
- 이런 공통적인 부분을 각각의 소스 프로그램 파일에 중복하여 작성하면 프로그램을 관리하기 어려워지고 이로인해 오류가 발생하기도 한다.
- C++ 헤더 파일은 이와 같은 공통부분을 별도로 작성한 것으로 보통 '.h'라는 확장자를 사용한다.
- 헤더파일은 단독으로 컴파일 되지 않고, #include라는 선행처리기 지시어에 의해 소스 프로그램에 삽입되어 함께 컴파일 된다.

## 프로그램의 빌드
- 소스 파일에 담겨 있는 프로그램은 컴퓨터가 직접 실행할 수 있는 프로그램이 아니다.
- 이것을 컴퓨터가 이해할 수 있는 명령으로 번역해야 한다. 이 과정을 컴파일 이라고 하며 컴파일은 컴파일러가 수행한다.

# C++ 프로그래밍 첫걸음
- 새로운 프로그래밍 언어를 배우는 첫걸음은 입출력을 포함한 간단한 프로그램을 작성해 보는 것이다

## 선행처리
- C++ 소스 프로그램은 컴파일 되기 전에 먼저 선행처리 과정을 거친다.
- 이 과정은 소스 프로그램을 가공하여 실제로 컴파일러가 번역할 소스 프로그램을 만드는데 선행처리기가 이 작업을 수행한다.
- 선행처리기가 어떤 작업을 할 것인가를 지시하는 명령을 선행처리기 지시어라고 한다.
- 선행처리기 지시어는 '#'으로 시작하며, 한 행에 한 문장씩 작성한다.

### #include
- 헤더 파일을 소스 프로그램에 결합하기
- #include<header> //표준 include 경로에 존재하는 파일
- #include "header" //현재 위치에 존재하는 파일

### #define,#undef
- 매크로 선언 및 해제

### #if,#ifdef,#ifndef
- 조건부 컴파일

### FirstStep.cpp
```c
#include <iostream>
//iostream : C++의 스트림 출력을 위한 사항들을 선언하는 내용을 담고 있는 헤더파일

//std::cout<<value;
// << : 삽입연산자

void main() {
	//표준 출력 스트림으로 문장을 출력함
	std::cout << "나의 첫번째 C++프로그램" << std::endl;
	//cout은 콘솔에 출력하는 기능을 제공

	//endl은 행의 끝(end of line)을 알리는 문자를 출력함으로써
	//다음에 출력하는 내용은 아래 행에 출력되게 한다.

	int a = 10;
	std::cout << "a의 값은 ";
	std::cout << a << "입니다." << std::endl;

}
```

## 네임스페이스
- C++에서 하나의 명칭은 한 번만 정의되어야 한다.
- 그런데 여러 개발자가 작성한 프로그램들을 묶어 하나의 프로그램을 만들 경우 같은 이름을 중복하여 정의할 우려가 있다.
- 변수,함수,구조체,클래스 등의 동일한 이름의 충돌 문제를 C++에서 해결하기 위해 사용되는 영역이다.

### NameSpace.cpp
```c
#include <iostream>

//'{' 와 '}'로 묶인 영역 내에 정의된 이름은 지정된 명칭공간에 속하게 된다.
namespace NameSpace1 { int a = 10; }
namespace NameSpace2 { int a = 20; }
int a = 30;
namespace NameSpace1 { int b = 50; }
//하나의 명칭 공간은 한 번에 모두 완성해야 하는것은 아니다.

void main() {
	int a = 40;

  //명칭공간 내에 정의된 이름을 그 영역의 밖에서 사용할 때는 영역식별 연산자(::)로 소속된 명칭공간을 지정해야 한다.
  //NameSpace1에 속한 a를 사용하려면 10행에서와 같이 NameSpace1::a라고 표기해야 한다.
	std::cout << NameSpace1::a << std::endl;
  //NameSpace2라는 명칭공간을 지정하였으므로 4행에 정의된 a의 값 20을 출력한다.
	std::cout << NameSpace2::a << std::endl;
  //::a와 같이 영역식별 연산자 앞에 명칭공간 이름이 없으면 전역 명칭공간에 정의된 a를 나타내는 것으로, 5행에 정의된 a가 이에 해당된다.
	std::cout << ::a << std::endl;
  //지역변수 a 출력
	std::cout << a << std::endl;
	std::cout << NameSpace1::b << std::endl;

//C++에 제공되는 표준 라이브러리의 이름들은 모두 std('standard'를 줄인 이름)라는 명칭공간에 포함된다.
//그러므로 NameSpace.cpp의 10~14행에서 사용한 cout과 endl이라는 이름에는 'std::'라고 명칭공간을 지정하였다.
}

```
- 특정 명칭공간에 정의된 이름을 자주 사용할 경우 매번 명칭공간을 지정하는 것이 번거로울 수 있다.
- 이러한 경우 다음과 같은 형식으로 using 구문을 사용하면 편리하다.

```c
using namespace namespace-name;//형식은 특정 명칭공간 내의 모든 이름을 명칭공간을 지정하지 않고 사용할 수 있게 한다.

using namespace-name::name; //특정 명칭공간 내의 특정 이름을 명칭공간을 지정하지 않고 사용할 수 있게 한다.
```

```c
using namespace std;
```
또는
```c
using std::cout;

using std::endl;
```
이라는 문장을 넣으면 다음과 같이 간편하게 작성할 수 있다.
```c
cout << NameSpace1::a << endl;

cout << NameSpace2::a << endl;

cout << ::a << endl;

cout << a << endl;

cout << NameSpace1::b << endl;
```

# 기본자료형
- 기본 자료형이란 프로그래밍 언어에서 데이터를 표현하기 위한 기본적인 표현 형식이다.

## 정수형
- short
- int
- long
- long long

## 문자형
- char  1byte







