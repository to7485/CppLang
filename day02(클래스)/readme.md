# 구조체
- 지금까지 사용한 int, float 등과 같은 자료형은 C++에 미리 정의되어 있는 기본 자료형이다.
- 이와는 별개로 프로그래머가 필요에 따라 새로운 자료형을 정의할 수 있다.
- 구조체를 사용자 정의 자료형이라고 할 수 있는데, 기본 자료형이나 앞서 선언된 사용자 정의 자료형을 이용하여 정의한다.

### 구조체 생성 방법
```c
struct 구조체명{
   Type1 변수명1;
   Type2 변수명2;
   ...
}
```
- Type1, Type2는 기본 자료형의 하나일 수도 있고, 먼저 정의된 사용자 정의 자료형일 수도 있다.

### 구조체 변수의 선언
```c
구조체명 변수명;
```

## 구조체 실습
- 원의 면적을 구하기
- 두 개의 원이 중첩되는지 검사하고 원의 정보 출력하기

### Circles1.cpp
```c
#include <iostream>

using namespace std;

const double PI = 3.141593;

struct C2dType { //2차원 좌표 구조체
	double x, y; 
};

struct CircleType {
	C2dType center; //중심좌표
	double radius; //반지름
};

//원의 면적을 구하는 함수
double circleArea(CircleType c) {
	return c.radius * c.radius * PI;
}

//두 원이 겹치는지 구하는 함수
bool chkOverlap(CircleType c1, CircleType c2) { //두 개의 원을 매개변수로 받는다.
	double dx = c1.center.x - c2.center.x;
	double dy = c1.center.y - c2.center.y;
	double dCntr = sqrt(dx*dx + dy * dy);
	return dCntr < c1.radius + c2.radius;
}

//원의 정보를 출력하는 함수
void dispCircle(CircleType c) {
	cout << " 중심 : (" << c.center.x << ", " << c.center.y << ")";
	cout << " 반경 : " << c.radius << endl;
}

void main() {
	CircleType c1 = { {0,0},10 }; //중심(0,0) 반지름 10으로 초기화
	CircleType c2 = { {30,10},5 }; //중심(0,0) 반지름 10으로 초기화

	cout << "원1" << endl;
	dispCircle(c1);
	cout << " 원1의 면적 : " << circleArea(c1) << endl;
	cout << "원2" << endl;
	dispCircle(c2);
	cout << " 원2의 면적 : " << circleArea(c2) << endl << endl;

	//두 원의 중첩 여부 출력
	if (chkOverlap(c1, c2)) {
		cout << "두 원은 중첩됩니다." << endl;
	}
	else {
		cout << "두 원은 중첩되지 않습니다." << endl;
	}

}
```

# 메모리 영역
- C++의 프로그램에서 사용하는 메모리는 일반적으로 4가지 영역으로 나눈다.

## Code영역
- 컴파일된 프로그램이 저장되는 영역

## Data영역
- 전역 변수, 정적(static) 변수가 저장되는 영역

## Heap영역
- 동적 할당된 변수가 할당되는 영역

## Statck영역
- 지역 변수, 매개변수 및 기타 함수 관련 정보가 저장되는 영역

# Heap영역
- Heap영역은 동적 메모리 할당에 사용되는 메모리를 추적한다.

## 메모리의 동적할당
- 필요할 때 기억공간을 할당하고 더 이상 그 공간이 필요하지 않으면 반환할 수 있게 하는 것.
- 그런데 동적 메모리 할당으로 생성된 저장공간은 이름이 없어 변수처럼 그 이름을 통해 액세스할 수 없다.
- 동적으로 할당된 저장공간을 포인터 변수가 가리키게 하면 그 포인터를 이용하여 액세스할 수 있다.


# 클래스
- 구조체(struct)는 프로그램으로 표현하고자 하는 대상에 대한 데이터의 구조만을 정의하고 있다.
- 클래스(class)는 마치 객체의 설계도와 같다.
- 클래스에는 객체가 포함할 속성에 대한 명세와 메소드들이 정의되어 있어
- 클래스를 이용하여 동일한 속성 및 메소드를 갖는 객체들을 생성한다.

# 객체
- 객체는 실세계의 문제영역에 존재하는 대상물을 그 대상물의 속성(attribute)과 메소드(method)로 모델링한 것이다.
- 객체의 속성은 그 객체의 상태를 나타내는 데이터이며, 객체의 메소드는 내부의 데이터를 사용하여 정해진 동작을 하는 함수이다.
- 사실 세상에 존재하는 모든 것들이 전부 대상이며, 어느 것은 객체로 표현되고 어느 것은 안 된다는 식으로 한계를 지을 수 없다.

# 메세지
- 하나의 프로그램에 객체가 하나만 존재하는 경우는 거의 없다. 일반적으로 여러 개의 객체가 포함되어 있으며, 프로그램이 필요한 기능을 해내기 위해서는 이들이 상호작용해야만 한다.
- 한 객체가 다른 객체의 기능을 필요로 한다면 그 객체는 상대방 객체에게 필요한 작업이 이루어지도록 요구한다.
- 이와 같이 상대방 객체에게 필요한 작업을 실행하도록 요구하는 것을 객체지향 프로그래밍에서는 메시지를 보낸다고 한다.
- 객체지향 언어에서 메시지를 보내는 것은 그 메시지를 처리할 메소드, 즉 함수를 호출하는 것을 의미한다.

![image](https://github.com/to7485/CppLang/assets/54658614/b282820d-3590-4530-a6bf-2aacb26cd3fb)

# 캡슐화
- 캡슐화(encapsulation)는 객체의 사용자 측면의 사항과 설계자 측면의 사항을 분리하는 것이다.
- 객체의 사용자에게는 객체에게 어떤 메시지를 어떻게 보냄으로써 그 객체가 동작하게 할 수 있는가에 대한 정보가 필요하다.
- 세부적인 객체 내부 상태의 표현이나 행위의 구현에 대해서는 알 필요가 없다.
(우리가 약을 먹는데 약이 어떤 재료로 이루어져있는지 까지는 알 필요가 없다.)
- 반면 설계자는 객체가 동작하게 하기 위한 세부적인 구현 부분을 정의해야 할 것이다.
- 객체지향 프로그래밍 언어에서는 캡슐화를 위해 공개할 멤버와 공개하지 않을 멤버를 구분할 수 있다.

![image](https://github.com/to7485/CppLang/assets/54658614/aca7d707-1d1d-4767-ad03-33bdc6ab285c)

## 클래스 선언과 객체의 정의
- 클래스는 C++ 언어에서 객체지향 개념을 구현하기 위한 도구로서
- 프로그램에서 사용하고자 하는 객체들에 대한 형판을 정의한 것으로 볼 수 있다.
- 클래스와 객체의 관계는 자료형과 변수의 관계와 유사하다.
- 그러나 클래스는 각각의 객체를 표현하는 속성과 함께 그 객체들에 대한 메시지를 처리하는 메소드를 정의해 놓은 것이다.
- C++ 언어에서는 클래스 안에 정의한 속성들을 데이터 멤버(data member)라고 부르고, 메소드를 멤버함수(member function)라고 부른다.

```c
class 클래스명{
  접근제어자:
      멤버변수 또는 멤버함수;
  접근제어자:
      멤버변수 또는 멤버함수;
  ...

}
```

## 접근제어자
- 그 다음에 나열되는 데이터 멤버나 멤버함수들이 외부에 공개되는 범위를 나타낸다.
- 다음 접근제어자가 나올 때까지 유효하다.
- 접근제어자 뒤에는 클래스의 데이터 멤버 및 멤버함수들이 나열된다.

### 접근제어자의 종류
|접근제어자| 공개되는 범위|
|----|-------|
|private|소속 클래스의 멤버함수<br>friend 클래스의 멤버함수 및 friend 함수|
|public| 전범위|

## 멤버의 선언
- 데이터 멤버는 일반적으로 private 멤버로 선언한다.
- 데이터 멤버를 공개하는 것이 불가능한 것은 아니다.
- 객체의 모델링은 객체의 행위를 중심으로 이루어지며,
- 데이터 멤버는 그러한 행위와 관련된 객체 내부의 상태로 보는 것이 일반적이어서 주로 private로 선언하는 것이다.

## 멤버 함수의 선언
- 멤버함수는 클래스 선언문 내에 선언하거나, 클래스 선언문에는 멤버함수의 원형만 선언해 놓고 외부에 별도로 멤버함수를 정의한다.

## 객체의 정의 및 사용
- 클래스 선언문은 클래스에 해당되는 객체가 갖게 되는 멤버들에 대하여 선언한 것이며, 실제 객체는 일반 자료형의 변수를 정의하듯 별도로 정의하여야 한다.
- 객체를 정의한다는 것은 실제 객체를 만드는 것을 의미한다.

### 객체 선언 방법
```c
클래스명 객체명;

클래스명 객체명1, 객체명2...;
```

## Counter.h
- 멤버로 숫자를 가지고 있다.
- 멤버 함수로 값을 1씩 증가시키는 count(), 현재 값을 얻어오는 getValue(), 값을 0으로 만드는 reset()이 있다.

```c
#ifndef COUNTER_H_INCLUDED

#define COUNTER_H_INCLUDED

class Counter {
	int value; //접근제어자가 지정되지 않았지만, 디폴트인 private이 지정된다.

public:
	void reset() {
		value = 0;
	}

	void count() {
		value += 1;
	}

	int getValue() const {
		return value;
	}
};

	// const 멤버 함수 : 멤버 함수 내에서 데이터 멤베덜의 값을
	//변경하지 않겠다.

	//만일 const 멤버함수 내에서 데이터 멤버의 값을 수정하면 
	//컴파일러가 오류 메세지를 보낸다.


#endif 
```

- 일반적으로 클래스를 선언할 때는 2개의 파일을 만든다.
- 클래스 선언문이 포함된 헤더 파일
- 클래스의 멤버함수들의 정의를 담고 있는 소스 프로그램 파일

## Counter.cpp
```c
#include <iostream>

#include "Counter.h"
using namespace std;

void main() {
	Counter cnt; //Counter 객체의 정의
	cnt.reset(); //숫자를 0으로 만듦
  //cout << "현재 값 : " << cnt.value << endl; 불가능
	cout << "현재 값 : " << cnt.getValue() << endl;
	cnt.count();
	cnt.count(); //값을 1증가시킴
	cout << "현재 값 : " << cnt.getValue() << endl;
}
```










