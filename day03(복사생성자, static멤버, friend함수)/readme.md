# 복사 생성자
- 같은 클래스의 객체를 복사하여 객체를 만드는 생성자이다.

## 컴파일러가 자동적으로 제공하는 복사 생성자. 
- 만일 복사 생성자를 명시적으로 선언하지 않으면 컴파일러는 원본 객체의 멤버들을 그대로 복사하여 객체를 정의하는 복사 생성자를 자동으로 만든다.
- 
```c
CounterM cnt4(99); 		// 1. 0부터 99까지 카운트하는 계수기 객체

CounterM cnt5(cnt4); 	// 2. cnt4를 복사한 계수기 객체 cnt5 정의

CounterM cnt6 = cnt4; 	// 3. cnt4를 복사한 계수기 객체 cnt6 정의
```
- cnt4는 데이터 멤버 maxValue와 value가 각각 99와 0인 상태로 정의될 것이다.
- 그런데 CounterM에는 2번과 같이 CounterM 클래스의 객체가 인수인 생성자는 명시적으로 선언하지 않았다.
- 컴파일러가 데이터 멤버를 1:1로 복사해 주는 복사 생성자를 자동적으로 만들어 놓기 때문에 2번과 같은 문장이 가능하며
- cnt5 역시 maxValue는 99, value는 0이라는 값으로 초기화된다.
- 3번의 문장은 대입이 아닌 초기화 문장이며, 이 경우에도 복사 생성자가 동작한다.
- 다음의 문장과는 다르다.
```c
CounterM cnt7(99);

cnt7 = cnt4;  	// 4. 에러! 이 문장은 초기화 문장이 아닌 대입 연산자임
```
- 문장4는 대입 연산자가 적용되는 문장이다.
- 컴파일러는 3과 같은 초기화와 4와 같은 대입을 다른 방법으로 취급한다.
- const 데이터는 초기화는 가능하지만 대입은 할 수 없다.

## 명시적으로 복사 생성자 정의하기
- 주의할 점은 형식 매개변수가 그 클래스의 참조형이어야 한다는 것이다.
- 문제는 객체에 필요한 메모리를 동적으로 할당받고 반납하도록 되어 있는 클래스에서 발생할 수 있다.
```c
class  CounterM {

……

  CounterM(const CounterM& c)

    : maxValuec.maxValue, valuec.value

……

 };
```

## vecF 클래스
- 벡터 객체를 만들 수 있는 VecF 클래스를 정의해보자.
- VecF 객체는 float 값의 수를 인수로 지정하여 생성된다.
- 저장할 값의 배열이 제공될 경우 그 값으로 초기화 한다.
- 인수로 전달된 VecF 개겣와 덧셈한 결과를 반환할 수 있다.
- 객체에 저장된 벡터를 출력할 수 있다.

### VecF클래스의 메서드
|메서드|비고|
|----|-------|
|VecF(int d, float* a)|생성자|
|~VecF()|소멸자|
|VecF add(const VecF& fv)|벡터의 덧셈을 한다.|
|void print() | 벡터를 출력한다|

### VecF클래스의 속성
|속성|비고|
|----|-------|
|int n|벡터의 크기를 저장한다.|
|float* arr|벡터의 저장공간 포인터|

## VecF.h
```c

```

